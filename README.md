# Data_Structure

Data_Structure Code Review

# 자료구조

## 2022.01.17 월요일

# 1️⃣ 자료구조와 알고리즘

## 자료구조란?

> 컴퓨터에서 자료들을 정리 또는 조직화하는 구조들
> 

---

![자료구조의 구성](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%202a786c065fd243ae81180e42824975f7/Untitled.png)

자료구조의 구성

- 자료구조의 분류
    - 단순 자료구조 : 많은 프로그래밍 언어에서 기본적으로 제공
    - 복합 자료구조 : 여러 가지 자료들이 복합적으로 구성
        - 선형 자료구조
            - 기본적으로 자료들이 순서대로 나열됨
            - 자료에 접근하는 방법
                - 순서 접근
                    - 예시 : 연결 리스트 - 시작 노드부터 하나씩 다음 노드로 이동하며 원하는 자료에 접근
                - 직접 접근
                    - 예시 : 배열 - 인덱스를 사용하여 i 번째 요소에 한 번만에 접근 가능
        - 비선형 자료구조
            - 자료들 간에 선형적인 순서가 있는 것이 아닌 복잡한 연결을 갖는 형태
            - 예시 : 트리, 그래프 등
                - 트리 - 회사의 조직도 또는 컴퓨터의 폴더와 같은 계층 구조를 표현하기에 적합
                - 그래프 - 지하철 노선도, SNS의 인맥 지도, 인터넷 망 등을 표현 가능한 가장 복잡한 형태의 자료구조

---

## 알고리즘이란?

> 프로그래밍 스타일이나 프로그래밍 언어와는 무관하게 어떤 문제를 해결하는 절차
> 

---

- **컴퓨터 프로그램 = 자료구조 + 알고리즘**
    - 자료구조를 사용하여 처리한 데이터를 표현하고 저장
    - 주어진 문제를 처리하는 절차 → 알고리즘
    
    ![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%202a786c065fd243ae81180e42824975f7/Untitled%201.png)
    
- 알고리즘의 조건
    
    <aside>
    💡 **입력** : 0개 이상의 입력 존재
    
    </aside>
    
    <aside>
    💡 **출력** : 1개 이상의 출력 존재
    
    </aside>
    
    <aside>
    💡 **명백성** : 각 명령어의 의미는 모호하지 않고 명확해야 함
    
    </aside>
    
    <aside>
    💡 **유한성** : 한정된 수의 단계 후에는 반드시 종료되어야 함
    
    </aside>
    
    <aside>
    💡 **유효성** : 각 명령어들은 실행 가능한 연산이어야 함
    
    </aside>
    
- 알고리즘 기술 방법
    - 자연어 (예시 : 영어, 한국어 등)
        - 기술이 편리하지만 모호성을 제거하기 위해 명령어로 쓰이는 단어들의 의미가 명백해야 함
        - 읽기는 쉬우나, 정확한 정의가 되지 않으면 모호해짐
    - 흐름도 (flow-chart)
        - 직관적이고 이해가 쉬움
        - 복잡한 알고리즘의 경우 그림이 복잡해질 위험이 존재
    - 유사 코드 (pseudo-code)
        - 자연어보다는 구조적이지만 프로그래밍 언어보다는 덜 구체적임
        - 문법에 맞지 않으므로 실행이 불가능하고 의미만 전달하는 역할 수행
        - 알고리즘 기술에 가장 많이 사용됨
    - 특정 프로그래밍 언어 (예시 : C++, java 등)
        - 가장 정확한 방법이긴 하지만 실행이 되어야 한다는 문제 존재
    
    ---
    
    ## 추상화란?
    
    > 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것으로 어떤 시스템의 간략화된 기술 또는 명세로서 시스템의 핵심적 구조나 동작에만 집중
    > 
    
    ---
    
    ## 추상 자료형이란?
    
    > Abstract Data Type (ADT), 추상적으로 정의한 자료형
    > 
    
    다시 말하면, 자료의 집합과 자료에 가해지는 연산들의 집합에 대한 수학적 명세로 데이터(객체, ‘클래스와 객체’에서의 ‘객체’와는 다른 의미)와 연산(기능)으로 정의한다.
    
    (예시) 자연수에 대한 추상 자료형
    
    **데이터**
    
    1에서 시작하여 INT_MAX까지의 순성화된 정수의 부분 범위 ⇒ 양의 정수를 의미
    
    **연산** 
    
    1. add(x, y) : x+y가 INT_MAX보다 크면 INT_MAX를 반환하고, 아니면 x+y를 반환
    2. distance(x, y) : x가 y보다 크면 x-y를 반환하고, 작으면 y-x를 반환
    3. equal(x, y) : x와 y가 같은 값이면 TRUE를 반환, 아니면 FALSE를 반환
    4. successor(x) : x가 INT_MAX보다 작으면 x+1을 반환
    
    ---
    
    ## C++과 추상 자료형의 관계
    
    <aside>
    💡 추상 자료형의 개념은 객체 지향의 개념과 정확히 일치
    
    </aside>
    
    <aside>
    💡 객체 지향 언어인 C++에서는 **“클래스”**를 사용해서 추상 자료형을 구현
    
    </aside>
    
    <aside>
    💡 추상 자료형에서의 **“데이터”**는 **클래스의 속성(멤버 변수)로 구현**되고, **“연산”**은 **클래스의 메소드(멤버 함수)로 구현**
    
    </aside>
    
    <aside>
    💡 C++에서는 private이나 protected 키워드를 이용하여 속성과 연산에 대한 접근을 제한 가능
    
    </aside>
    
    <aside>
    💡 클래스는 계층 구조(상속)로 구성 가능
    
    </aside>
    
    ---
    
    ## 알고리즘 성능 분석과 실행 시간 측정 방법
    
    성능 분석을 하기 위해 실제로 구현을 해서 실행 시간을 측정하는 것은 동일한 하드웨어를 사용해야 정확한 비교가 가능하고, 동일한 환경 하에서도 실행 시점마다 차이를 보이기 때문에 의미가 없다. 
    
    알고리즘 성능 분석에서의 **‘좋은 알고리즘’**은 ‘실행 시간이 빠르고 처리를 위한 기억 공간이 적은 알고리즘’을 의미한다. **알고리즘의 실행 시간 분석**을 “시간 복잡도”라고 하고, **알고리즘이 사용하는 기억 공간 분석**을 “공간 복잡도”라고 한다. 
    
    ### 시간 복잡도 함수
    
    > 알고리즘을 이루고 있는 연산들이 몇 번이나 실행되는지를 숫자로 표시
    > 
    
    연산에는 산술 연산, 대입 연산, 비교 연산, 이동 연산 등이 모두 포함됨
    
    어떤 알고리즘을 실행하는 데 필요한 연산의 수는 보통 **입력 개수 n**에 영향을 받는다.  연산의 수를 n의 함수로 나타낸 것 을 **시간 복잡도 함수**라고 하고 T(n)으로 표기한다. 
    
    ### 빅오 표기법
    
    > 시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법
    > 
    
    (예시) 시간 복잡도 함수  $T(n) = n^2 + n + 1$
    
    - n = 1 일 때 :  $T(n) = 1 + 1 + 1 = 3$  ($n^2$항이 33.3%)
    - n = 10 일 때 :  $T(n) = 100 + 10 + 1 = 111$  ($n^2$항이 90%)
    - n = 100 일 때 :  $T(n)=10000+100+1=10101$ ($n^2$항이 99%)
    
    <aside>
    💡 시간 복잡도 분석에서는 함수의 전체 항이 아니라 **최고차항만을 고려**하면 될 것이다.
    
    </aside>
    
    즉, ‘n이 증가함에 따라 무엇에 비례하는 수의 연산이 필요한가?’가 중요한 요소!
    
    $$
    O(1) < O(log n) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!)
    $$
    
    ⇒ 실행시간을 비교한 결과로 왼쪽이 효율이 높고 오른쪽으로 갈수록 효율이 떨어지게 됨 (1은 상수의 상징적 의미를 가진다.)
    

# 2️⃣ 배열과 클래스

## 배열의 개념

> 기본이 되는 중요한 자료형으로 주로 여러 개의 동일한 자료형의 데이터를 한꺼번에 만들 때 사용
> 

---

- 배열의 특징
    - 동일한 이름을  사용하고, 인덱스(index) 번호를 사용하여 각 항목에 접근
    - 반복문을 사용하여 코드의 길이를 줄일 수 있음
    - **<인덱스, 요소> 쌍의 집합** → 인덱스가 주어지면 해당하는 요소가 대응되는 자료구조로 모든 요소가 동일한 자료형이며 인덱스를 사용하여 직접 접근하는 형태

---

## 배열의 추상 자료형

**데이터**

<인덱스, 요소> 쌍의 집합

**연산** 

1. create(n) : n개의 요소를 가진 배열을 생성
2. retrieve(i) : 배열의 i번째 요소를 반환
3. store(i, item) : 배열의 i번쨰 위치에 item을 저장한다. 

---

- 1차원 배열
    - 선언 방법
        - 자료형 배열이름[배열크기];
            - 자료형 : 배열 요소들의 자료형으로 모든 요소들은 같은 자료형으로 생성됨
            - 배열이름 : 배열의 요소에 접근할 수 있는 유일한 이름
            - 배열크기 : 배열 요소의 개수를 나타내는 정수로 배열 요소의 인덱스는 0부터 배열크기-1
        - 요소들이 **모두** 메모리의 **연속된 공간**에 저장
            - 예시 : int A[6];
                - 정수 배열. 첫 번째 요소는 A[0]이고 마지막 요소는 A[5]
                - A는 배열의 시작 주소(기본 주소)
                - 배열의 요소들은 기본 주소로부터 일정하게 계산되어 저장
                    - sizeof 연산자 : 자료형의 크기 계산
- 문자열
    
    <aside>
    💡 1차원 배열의 한 종류로 char형의 요소를 갖는 배열
    
    </aside>
    
    하나의 문자는 주로 ‘a’처럼 작은 따옴표로 표현하지만, 문자열은 문자들을 모은 것으로 “Hello”처럼 큰 따옴표로 표현. 문자열을 저장하기 위해서는 char형 배열 1차원 배열을 사용
    
    (예시) 문자 배열을 “game over”로 초기화
    
    char s[12] = “game over”;
    
    ![문자열 s에 대한 메모리 구조](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%202a786c065fd243ae81180e42824975f7/Untitled%202.png)
    
    문자열 s에 대한 메모리 구조
    
    **문자열 맨 끝에는 s[9]처럼 반드시 문자열의 끝을 나타내는 NULL 문자 ‘\0’ 필수!**
    
    s[4]는 공백문자 ‘ ‘를 나타내는 것으로 문자열의 일부분에 해당
    
- 2차원 배열
    
    <aside>
    💡 1차원 배열이 여러 개 모여서 이루어진 배열로 **가로줄이 ‘행’, 세로줄이 ‘열’**에 해당
    
    </aside>
    
    - 선언 방법
        - 자료형 배열이름[행의_크기][열의_크기];
            - 배열이름 : 2차원 배열의 이름
            - 행의_크기 : 2차원 배열의 가로줄 개수
            - 열의_크기 : 2차원 배열의 세로줄 개수
            - 예시 : int A[4][3];
                - 행의 크기 : 4, 열의 크기 : 3
                - 2차원 배열
                    
                    
                    | A[0][0] | A[0][1] | A[0][2] |
                    | --- | --- | --- |
                    | A[1][0] | A[1][1] | A[1][2] |
                    | A[2][0] | A[2][1] | A[2][2] |
                    | A[3][0] | A[3][1] | A[3][2] |
                - 실제 메모리 안에서의 위치
                    
                    
                    | A[0][0] |
                    | --- |
                    | A[0][1] |
                    | A[0][2] |
                    | A[1][0] |
                    | A[1][1] |
                    | ... |
                    | A[3][2] |
            - 2차원 배열의 초기화
                - int A[4][3] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9}, {10, 11, 12} };

---

## 함수 파라미터로서의 배열

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%202a786c065fd243ae81180e42824975f7/Untitled%203.png)

<aside>
💡 **함수 내에서 파라미터로 배열을 받아 배열의 내용을 수정하면 원래의 배열이 수정된다.**

</aside>

배열의 이름은 ‘포인터 역할’을 수행!

**⇒ 배열의 이름을 전달 → 배열의 포인터(첫 번째 항목의 주소)가 전달되는 것과 동일하므로 주의!!**

<aside>
💡 **매개변수로 배열의 길이도 전달해야 한다.**

</aside>

배열의 이름이 포인터 역할을 하므로 배열의 이름을 매개변수로 전달하면 호출되는 함수에서는 이 주소를 이용하여 배열의 모든 요소들에 접근이 가능해지는데, 이 때 배열의 길이를 알  수 있는 방법이 없으므로 **배열의 이름을 매개변수로 전달하는 경우에는 배열의 길이도 반드시 함께 전달 필요!!**

<aside>
💡 **2차원 이상의 다차원 배열의 매개변수 전달 시 가로의 크기는 꼭 지정해야 하고, 행과 열의 크기를 함께 매개변수로 받아야 하며 이 때, 열의 크기는 지정한 가로 크기와 필수적으로 동일해야 한다.**

</aside>

문제점은 가로 크기가 지정된 크기인 영상에 대해서만 적용 가능하다는 것이다. 

---

## 클래스의 선언

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%202a786c065fd243ae81180e42824975f7/Untitled%204.png)

class의 선언은 class 또는 struct 예약어를 사용해서 선언

---

<aside>
💡 함수 오버로딩 : 함수 이름의 중복을 허용하는 것

</aside>

클래스의 멤버 함수나 일반 함수 모두에서 가능. **매개변수의 개수, 타입 등이 달라야 한다**는 특징

---

<aside>
💡 함수 오버라이딩 : 자식 클래스에서 부모 클래스의 멤버 함수들을 재 정의하는 것

</aside>

오버라이딩한 멤버 함수의 **매개변수 타입, 개수와 반환형이 부모 클래스의 멤버 함수와 동일해야 한다**는 특징

---
